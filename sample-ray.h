// sample-ray.h -- Directional light samples
//
//  Copyright (C) 2005, 2006  Miles Bader <miles@gnu.org>
//
// This file is subject to the terms and conditions of the GNU General
// Public License.  See the file COPYING in the main directory of this
// archive for more details.
//
// Written by Miles Bader <miles@gnu.org>
//

#ifndef __SAMPLE_RAY_H__
#define __SAMPLE_RAY_H__

#include <vector>

#include "vec.h"
#include "color.h"

namespace Snogray {

class Light;

// A single directional sample.  The origin is implicit, because samples
// are typically taken from a single point, so only the direction is
// included.
//
class SampleRay
{
public:

  SampleRay (const Color &_val, const Vec &_dir, dist_t _dist,
	     const Light *_light)
    : val (_val), dir (_dir), dist (_dist), light (_light), refl (0)
  { }
  SampleRay (const Color &_refl, const Vec &_dir)
    : val (0), dir (_dir), dist (0), light (0), refl (_refl)
  { }

  // Set the light source of an existing sample (presumably generated by
  // the brdf) to _LIGHT, having irradiance IRR from distance _DIST.
  //
  void set_light (const Color &irr, dist_t _dist, const Light *_light)
  {
    val = irr * refl;
    light = _light;
    dist = _dist;
  }

  // Set the reflectivity of an existing sample (presumably generated by
  // the light) to REFL, updating the sample value.
  //
  void set_refl (const Color &_refl)
  {
    val *= _refl;
    // It's not really necessary to update the REFL field, as that only
    // gets used with BRDF-generated samples.
  }

  // Mark this sample as pointless (having zero irradiance)
  //
  void invalidate ()
  {
    val = 0;
  }

  // For samples generated by a light, before filtering, this is the
  // amount of light reaching the sample origin; after filtering this is
  // the product of the incoming light and the reflectivity.
  //
  Color val;

  // The sample direction (the origin is implicit).
  //
  Vec dir;

  // How far away the light producing this sample is (0 for none).
  //
  dist_t dist;

  // The light producing this sample.
  //
  const Light *light;

  // For samples generated by a BRDF, this is the reflectance of the
  // BRDF for the sample direction; otherwise it is undefined.
  //
  Color refl;
};

class SampleRayVec
{
public:

  typedef std::vector<SampleRay>::iterator iterator;

  // Add a new sample generated by the light source.  The reflectivity
  // of the sample should be set later by the BRDF.
  //
  void add_light (const Color &val, const Vec &dir, dist_t dist,
		  const Light *light)
  {
    samples.push_back (SampleRay (val, dir, dist, light));
  }

  // Add a new sample generated by the BRDF.  The light source
  // of the sample should be set later.
  //
  void add_refl (const Color &refl, const Vec &dir)
  {
    samples.push_back (SampleRay (refl, dir));
  }

  // Accessors
  //
  unsigned size () const { return samples.size (); }
  const SampleRay &operator[] (unsigned i) const { return samples[i]; }
  SampleRay &operator[] (unsigned i) { return samples[i]; }

  iterator begin () { return samples.begin (); }
  iterator end () { return samples.end (); }

  void clear () { samples.clear (); }
  void reserve (unsigned num_samples) { samples.reserve (num_samples); }

  std::vector<SampleRay> samples;
};

}

#endif /* __SAMPLE_RAY_H__ */

// arch-tag: e0f3f775-1fab-4835-8d9f-4cd8b9729731
